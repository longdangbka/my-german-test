<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Current Implementation</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ccc; background: #f9f9f9; }
        .result { background: #e6f3ff; padding: 10px; margin: 10px 0; border-left: 4px solid #0066cc; }
        .error { color: red; background: #ffe6e6; }
        .success { color: green; }
        .step { margin: 10px 0; padding: 5px; background: #f0f0f0; }
    </style>
</head>
<body>
    <h1>Debug Current Implementation - Processing Order</h1>
    <div id="results"></div>

    <script>
        // Test the complete processing pipeline
        
        // Step 1: New parseClozeMarkers function
        function parseClozeMarkers(text) {
          if (!text || typeof text !== 'string') {
            return [];
          }
          
          const markers = [];
          let i = 0;
          
          while (i < text.length) {
            // Look for cloze pattern: {{c::
            if (text[i] === '{' && text[i + 1] === '{' && 
                text[i + 2] === 'c' && text[i + 3] === ':' && text[i + 4] === ':') {
              
              const start = i;
              i += 5; // Skip opening {{c::
              let content = '';
              let braceCount = 1; // We've seen one opening {{
              
              while (i < text.length && braceCount > 0) {
                const char = text[i];
                
                if (char === '}' && text[i + 1] === '}') {
                  // End of cloze marker
                  braceCount--;
                  if (braceCount === 0) {
                    i += 2; // Skip closing }}
                    break;
                  } else {
                    content += char;
                    i++;
                  }
                } else {
                  content += char;
                  i++;
                }
              }
              
              if (braceCount === 0) {
                markers.push({
                  match: `{{c::${content}}}`,
                  content: content,
                  start: start,
                  end: i
                });
              } else {
                // Unmatched braces, treat as regular text
                i = start + 1;
              }
            } else {
              i++;
            }
          }
          
          return markers;
        }

        // Step 2: Simulate cloze processing
        function processClozeQuestion(rawText) {
          console.log('=== Processing Cloze Question ===');
          console.log('Input:', rawText);
          
          // Step 1: Parse cloze markers
          const clozeMarkers = parseClozeMarkers(rawText);
          console.log('Step 1 - Cloze markers found:', clozeMarkers);
          
          // Step 2: Extract blanks
          const blanks = clozeMarkers.map(marker => marker.content);
          console.log('Step 2 - Blanks extracted:', blanks);
          
          // Step 3: Replace markers with blanks
          let processedText = rawText;
          for (let i = clozeMarkers.length - 1; i >= 0; i--) {
            const marker = clozeMarkers[i];
            processedText = processedText.slice(0, marker.start) + '_____' + processedText.slice(marker.end);
          }
          console.log('Step 3 - Text with blanks:', processedText);
          
          // Step 4: Check for LaTeX in the processed text (should still be there)
          const latexMatches = processedText.match(/\$[^$]+\$/g) || [];
          console.log('Step 4 - LaTeX in processed text:', latexMatches);
          
          // Step 5: Check for LaTeX in blanks (should be preserved)
          const latexInBlanks = blanks.filter(blank => blank.includes('$'));
          console.log('Step 5 - Blanks containing LaTeX:', latexInBlanks);
          
          return {
            original: rawText,
            processedText,
            blanks,
            clozeMarkers,
            latexInProcessedText: latexMatches,
            latexInBlanks: latexInBlanks
          };
        }

        // Test cases
        const testCases = [
          '{{c::Machen $x=1$}} Sie bitte während der Führung Handys und Smartphones.',
          'Text with normal $LaTeX$ and {{c::cloze $content$}} mixed.',
          '{{c::$a^2 + b^2 = c^2$}} is the Pythagorean theorem.',
          '{{c::Test}} with normal {{c::multiple}} blanks.',
          'Normal text with $math$ but no cloze markers.'
        ];

        const resultsDiv = document.getElementById('results');

        testCases.forEach((testCase, index) => {
          const testDiv = document.createElement('div');
          testDiv.className = 'test-case';
          
          try {
            const result = processClozeQuestion(testCase);
            
            let expectedBehavior = '';
            if (result.blanks.length > 0) {
              expectedBehavior = '✅ Should render as CLOZE with input fields';
            } else {
              expectedBehavior = '❌ Should render as plain text';
            }
            
            testDiv.innerHTML = `
              <h3>Test ${index + 1}</h3>
              <div class="step"><strong>Input:</strong> ${testCase}</div>
              <div class="step"><strong>Cloze Markers:</strong> ${JSON.stringify(result.clozeMarkers)}</div>
              <div class="step"><strong>Processed Text:</strong> ${result.processedText}</div>
              <div class="step"><strong>Blanks:</strong> ${JSON.stringify(result.blanks)}</div>
              <div class="step"><strong>LaTeX in processed text:</strong> ${JSON.stringify(result.latexInProcessedText)}</div>
              <div class="step"><strong>LaTeX in blanks:</strong> ${JSON.stringify(result.latexInBlanks)}</div>
              <div class="result ${result.blanks.length > 0 ? 'success' : 'error'}">
                <strong>Expected Result:</strong> ${expectedBehavior}<br>
                <strong>LaTeX Rendering:</strong><br>
                - Processed text LaTeX (surrounding content): Should render immediately<br>
                - Blank LaTeX (answers): Should render only when showing feedback
              </div>
            `;
          } catch (error) {
            testDiv.innerHTML = `
              <h3>Test ${index + 1} <span class="error">ERROR</span></h3>
              <div><strong>Input:</strong> ${testCase}</div>
              <div class="result error">
                <strong>Error:</strong> ${error.message}<br>
                <strong>Stack:</strong> ${error.stack}
              </div>
            `;
          }
          
          resultsDiv.appendChild(testDiv);
        });
    </script>
</body>
</html>
