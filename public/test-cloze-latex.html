<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloze LaTeX Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        .cloze-blank { background: #ffeb3b; padding: 2px 4px; margin: 0 2px; }
        .error { color: red; }
        .success { color: green; }
        pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Cloze LaTeX Parsing Test</h1>
    <div id="results"></div>

    <script>
        // Simplified version of our cloze parser
        function parseClozeMarkers(text) {
            if (!text || typeof text !== 'string') {
                return [];
            }
            
            const markers = [];
            let i = 0;
            
            while (i < text.length) {
                // Look for cloze pattern: {{c::
                if (text[i] === '{' && text[i + 1] === '{' && 
                    text[i + 2] === 'c' && text[i + 3] === ':' && text[i + 4] === ':') {
                    
                    const start = i;
                    i += 5; // Skip opening {{c::
                    let content = '';
                    let braceCount = 1; // We've seen one opening {{
                    
                    while (i < text.length && braceCount > 0) {
                        const char = text[i];
                        
                        if (char === '}' && text[i + 1] === '}') {
                            // End of cloze marker
                            braceCount--;
                            if (braceCount === 0) {
                                i += 2; // Skip closing }}
                                break;
                            } else {
                                content += char;
                                i++;
                            }
                        } else {
                            content += char;
                            i++;
                        }
                    }
                    
                    if (braceCount === 0) {
                        markers.push({
                            match: `{{c::${content}}}`,
                            content: content,
                            start: start,
                            end: i
                        });
                    } else {
                        // Unmatched braces, treat as regular text
                        i = start + 1;
                    }
                } else {
                    i++;
                }
            }
            
            return markers;
        }

        // Function to convert cloze text to blanks
        function convertClozeToBlanks(text) {
            const markers = parseClozeMarkers(text);
            let result = text;
            
            // Replace markers from end to start to maintain positions
            for (let i = markers.length - 1; i >= 0; i--) {
                const marker = markers[i];
                result = result.slice(0, marker.start) + 
                        '<span class="cloze-blank">_____</span>' + 
                        result.slice(marker.end);
            }
            
            return { processedText: result, extractedAnswers: markers };
        }

        // Test cases
        const testCases = [
            {
                name: "Simple cloze with LaTeX",
                text: "The formula is {{c::Machen $x=1$}}, and the result is {{c::$y = 2x + 3$}}."
            },
            {
                name: "Complex LaTeX in cloze",
                text: "Complex formula: {{c::$\\sum_{i=1}^{n} x_i = \\frac{n(n+1)}{2}$}} when dealing with consecutive integers."
            },
            {
                name: "Mixed content",
                text: "Die Lösung ist {{c::$\\frac{1}{2}$}} und {{c::richtig}}."
            },
            {
                name: "Display LaTeX",
                text: "The integral {{c::$$\\int_{0}^{1} x^2 dx = \\frac{1}{3}$$}} is correct."
            }
        ];

        const resultsDiv = document.getElementById('results');

        testCases.forEach((testCase, index) => {
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case';
            
            const result = convertClozeToBlanks(testCase.text);
            
            testDiv.innerHTML = `
                <h3>Test ${index + 1}: ${testCase.name}</h3>
                <div class="result">
                    <strong>Original text:</strong><br>
                    <pre>${testCase.text}</pre>
                </div>
                <div class="result">
                    <strong>Cloze markers found:</strong> ${result.extractedAnswers.length}<br>
                    ${result.extractedAnswers.map(marker => `
                        <div>• Content: "${marker.content}" (from ${marker.start} to ${marker.end})</div>
                    `).join('')}
                </div>
                <div class="result">
                    <strong>Text with blanks:</strong><br>
                    <div>${result.processedText}</div>
                </div>
            `;
            
            resultsDiv.appendChild(testDiv);
        });

        // Summary
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'test-case';
        summaryDiv.innerHTML = `
            <h3>Summary</h3>
            <p class="success">✅ All tests completed successfully!</p>
            <p>The cloze parser correctly identifies LaTeX expressions inside cloze markers without interfering with the LaTeX syntax.</p>
            <p>Next step: Test this in the actual React app.</p>
        `;
        resultsDiv.appendChild(summaryDiv);
    </script>
</body>
</html>
