<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Cloze Parser - Browser Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-case { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <h1>Debug Cloze Parser - Browser Test</h1>
    <div id="results"></div>

    <script>
        // Copy the new parseClozeMarkers function with {{c::[content]}} syntax
        function parseClozeMarkers(text) {
          console.log('üîç parseClozeMarkers called with text:', text);
          
          if (!text || typeof text !== 'string') {
            console.warn('üîç parseClozeMarkers - Invalid input text:', text);
            return [];
          }
          
          const markers = [];
          let i = 0;
          
          while (i < text.length) {
            // Look for cloze pattern: {{c::
            if (text[i] === '{' && text[i + 1] === '{' && 
                text[i + 2] === 'c' && text[i + 3] === ':' && text[i + 4] === ':') {
              
              const start = i;
              i += 5; // Skip opening {{c::
              let content = '';
              let braceCount = 1; // We've seen one opening {{
              
              while (i < text.length && braceCount > 0) {
                const char = text[i];
                
                if (char === '}' && text[i + 1] === '}') {
                  // End of cloze marker
                  braceCount--;
                  if (braceCount === 0) {
                    i += 2; // Skip closing }}
                    break;
                  } else {
                    content += char;
                    i++;
                  }
                } else {
                  content += char;
                  i++;
                }
              }
              
              if (braceCount === 0) {
                markers.push({
                  match: `{{c::${content}}}`,
                  content: content,
                  start: start,
                  end: i
                });
              } else {
                // Unmatched braces, treat as regular text
                i = start + 1;
              }
            } else {
              i++;
            }
          }
          
          console.log('üîç parseClozeMarkers returning markers:', markers);
          return markers;
        }

        // Test cases with new syntax
        const testCases = [
          '{{c::Machen $x=1$}} Sie bitte w√§hrend der F√ºhrung Handys und Smartphones.',
          '{{c::Test}} normal text',
          '{{c::LaTeX $\\alpha + \\beta$}} equation',
          'No markers here',
          '{{c::Multiple}} {{c::markers}} test',
          // Test old syntax should NOT work
          '{{old syntax}} should not match',
          'Text with $normal \\LaTeX$ and {{c::cloze $content$}} mixed.'
        ];

        const resultsDiv = document.getElementById('results');

        testCases.forEach((testCase, index) => {
          const testDiv = document.createElement('div');
          testDiv.className = 'test-case';
          
          try {
            const result = parseClozeMarkers(testCase);
            
            // Process like the app would
            let processedText = testCase;
            const blanks = [];
            
            const sortedMarkers = result.sort((a, b) => b.start - a.start);
            sortedMarkers.forEach(marker => {
              blanks.unshift(marker.content);
              processedText = processedText.slice(0, marker.start) + '_____' + processedText.slice(marker.end);
            });
            
            testDiv.innerHTML = `
              <h3>Test ${index + 1} <span class="success">‚úì</span></h3>
              <div><strong>Input:</strong> ${testCase}</div>
              <div class="result">
                <strong>Parsed markers:</strong> ${JSON.stringify(result, null, 2)}<br>
                <strong>Processed text:</strong> ${processedText}<br>
                <strong>Blanks:</strong> ${JSON.stringify(blanks)}
              </div>
            `;
          } catch (error) {
            testDiv.innerHTML = `
              <h3>Test ${index + 1} <span class="error">‚úó</span></h3>
              <div><strong>Input:</strong> ${testCase}</div>
              <div class="result error">
                <strong>Error:</strong> ${error.message}<br>
                <strong>Stack:</strong> ${error.stack}
              </div>
            `;
          }
          
          resultsDiv.appendChild(testDiv);
        });
    </script>
</body>
</html>
